import net.minecraftforge.gradle.common.util.ModConfig

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}
apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'eclipse'
apply plugin: 'maven-publish'

repositories {
    maven { // TOP
        name 'tterrag maven'
        url "https://maven.tterrag.com/"
    }
    maven { // JEI
        url "http://dvs1.progwml6.com/files/maven"
    }
}

version = '1.0'
group = 'com.yourname.modid' // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = 'modid'

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
    updateAT()
    mappings channel: 'snapshot', version: "${mcp_mappings}"
    accessTransformer = project.file("src/main/resources/META-INF/accesstransformer.cfg")

    List<ModConfig> modConfigs = new ArrayList<>()

    if (this.getRootProject() != null) {
        for (Project p in this.getRootProject().getSubprojects()) {
            if (p.getName() != this.getName()) {
                println("Found Mod Project " + p.getName() + ", making forge find it!")
                ModConfig modConfig = new ModConfig(p, p.getName());
                modConfig.source(p.sourceSets.main)
                modConfigs.add(modConfig);
            }
        }
    }

    runs {
        client {
            workingDirectory project.file('run')
            property 'forge.logging.console.level', 'debug'
            mods.addAll(modConfigs)
        }

        server {
            workingDirectory project.file('run')

            property 'forge.logging.console.level', 'debug'
            mods.addAll(modConfigs)
        }
    }
}

void updateAT() {
    Map<String, File> files = new HashMap<>()
    if(this.getRootProject() != null) {
        for(Project p in this.getRootProject().getSubprojects()) {
            if(p.getName() != this.getName()) {
                File file = p.file('src/main/resources/META-INF/accesstransformer.cfg');
                if(file.exists()) {
                    println("Found AT for " + p.getName() + "@[" + file.path + "]")
                    files.put(p.getName(), file);
                }
            }
        }
    }
    File atFile = project.file("src/main/resources/META-INF/accesstransformer.cfg")
    if(!atFile.exists()) {
        println(atFile.getName())
        atFile.createNewFile();
    }
    String text = "#Don't Edit This file!, it it gen from the build.gradle \n"
    for (Map.Entry<String, File> entry in files) {
        text += "#" + entry.getKey() + "\n";
        text += entry.getValue().text + "\n";
    }
    atFile.setText(text)
}

gradle.taskGraph.whenReady { graph ->
    def hasRootRunTask = graph.hasTask(':genIntellijRuns')
    if (hasRootRunTask) {
        graph.getAllTasks().each { task ->
            def subRunTask = (task.path =~ /:.+:genIntellijRuns/)
            if (subRunTask) {
                task.enabled = false
            }
        }
    }
}

dependencies {
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

    if(this.getRootProject() != null) {
        this.getRootProject().getSubprojects().each { Project p ->
            if(p.getName() != this.getName()) {
                runtimeClasspath p;
            }
        }
    }

}

task settings {
    project.ext.devWorkspace = true
}

subprojects.each { subproject ->
    evaluationDependsOn(subproject.path)
}